In the previous lecture we have seen how
the lifecycle of an actor looks like.
That it starts, that it may be restarted
and that it finally stops.
This life cycle has implications and we'll
see 2 of these in this session.
When we look at an actor from the outside,
the only thing we can
see about the life cycle is the transition
it goes through when it stops.
The only actor which can observe that
another
actor starts is the one which creates it.
And as soon as it has it has the actor ref
in hand, the child actor has at least
been alive for some period of time.
Other actors which learn of the existence
of this actor by getting the actor ref,
know also
that at some point in time, the actor was
alive.
But in order to find out more, they need
to exchange messages with it.
We have seen that restarts are not
externally visible.
The ActorRef stays valid.
And if the restart is successful, the
actor will handle messages afterwards
again meaning that an external observer
cannot really tell if an actor was
restarted or not.
The only thing which can be seen is if the
actor stops responding.
But what does it mean if we don't hear
back from somebody we call?
It might be that the other end is just not
there anymore.
It might also be that our means of
communication are broken.
To remove the ambiguity between an actor
which has terminated and
one which is just not replying anymore,
there exists the feature called
DeathWatch, which is a means to monitor
the life cycle of an actor.
Any actor can register its interest in
Monitoring the life cycle of an Actor
for which it has the ActorRef by
calling context.watch and giving it the
target ActorRef.
When the target Actor terminates, the
Actor
which monitors it will receive a
terminated message.
Within this message, the actor ref is
given
of the target which it was that just
terminated.
So that the monitor can disambiguate
between multiple actors it might be
monitoring.
The meaning of this terminated message is
that this actor
will not receive any further direct
communication from the target.
Of course, messages might still be en
route if
they were sent via different intermediate
actors, but direct messages
sent from the target to the monitoring
actor will
have been received before the terminated
message, if at all.
The DeathWatch API consists of 2 methods.
Which are offered on the actor context.
Watch given a target when registered
that we want to watch that target.
And unwatch on the other hand will remove
this registration.
Akka takes care that after you called
unwatch, the
terminated message for that target will no
longer be delivered.
This holds true even in the case when
unwatch is
called at the time during which the actor
is currently terminating.
There is no race condition here.
The third
piece of the API is the terminated message
itself.
There are a few things to be noted about
it.
First of all Terminated is a special
message.
You cannot create it yourself, hence it is
declared private except for our Akka.
This prohibits your code to use the
constructor or the companion objects apply
method.
The main data this message
transports is the ActorRef of the Actor
which has
terminated, but there are 2 additional
bits of information.
First of all, whether the existence of
this Actor could be confirmed.
By the system and the second gives
information
whether this message has been synthesized
by the system.
As we will learn in the next session.
I'll explain the first of the 2 flags with
a little drawing here.
Let's say, we have one actor here.
The watcher
which wants to watch another actor here,
the
watchee.
Let's make up some words.
If the watch message Is delivered while
the watchee is alive.
That registers just a call back
[INAUDIBLE],
so to speak for when the actor stops.
During this process, the terminator will
be sent.
And in this case,
the system knows that the actor has
existed, because the actor itself sent the
message.
After an actor stops, its Ref might stay
there.
But the actor itself is completely gone,
removed from the system.
So if the watch comes in at this point,
then the reply is generated by the
system when it cannot find the target.
And in this case the flag is set to false,
because akka does not know whether this
actor has ever existed.
The actor ref could for all intents and
purposes have been faked.
Now that we know about the data which are
contained in
a terminated message, there are 2 extra
pieces of information here.
First, it extends a trait called
AutoReceiveMessage which is an akka
marker trait signalling that terminated
messages
are handled by the ActorContext
especially.
The reason for this is that the terminated
message must not be delivered
after unwatch has been called.
And what this also means is that
terminated messages cannot be forwarded.
The last piece of information here is that
Terminated is possibly harmful.
And we will see later what that means.
Let us now see how we can use this
feature.
The first place where we try it out is the
getter from the link checker example which
has been used
throughout the last weeks.
This getter retrieves a body of
an HTML document from the web somewhere,
extracts all links, and then it used
to, after sending back the links, send to
its parent a done message.
This can be removed.
In this case, we just stop ourselves, and
in case of failure, we also just stop
ourselves.
Because the purpose of the done message
was to serve as an end
of conversation marker so that the parent
knows when the getter is done.
Using DeathWatch, that is no longer
necessary.
Once the getter stops, a terminated will
be delivered, and that serves the same
purpose.
Before we can look at how we need to
modify the controller,
which was the parent, if you remember
there is one more thing
we need to talk about.
We see here, and we have seen, every actor
is created by by one other actor, its
parent.
That also means that every actor can be
the parent to possibly many child actors.
And the context keeps a list of all the
children.
You can access it by calling
context.children,
which gives an iterable of actor refs, or
you can also query it by taking a name and
asking does this
child exist, and then you get back either
some actor ref or none.
The list which is kept by the actor
context follows very clear semantics.
When you call context actor and the call
returns, the
child has in the process been entered in
to the list.
As soon as the child terminates, it will
tell
its parents even if you do not use
DeathWatch.
And the parent will remove the child from
the list.
If you do use
DeathWatch, then that will have happened
before you received the terminated
message.
This is important because at any given
time, there
can be only one child of a given actor.
Which has a certain name.
If you try to create another child with
the same name, then you will get an
exception.
The reason for this is precisely the
children list.
Actors are identified by their names,
hence they must be unique.
Now we can finish the modification of
the relationship between getter and
controller using DeathWatch.
First of all, we install a supervisor
strategy.
We use a one for one strategy.
And in all cases of exceptions, we say
restart, but we only do that 5 times.
Once a getter has failed 5 times, it will
be stopped.
The second modification is that we do not
need to keep our own list of child actors.
We had a map in this actor.
Instead we apply context watch to the
result of context actorOf here,
which registers our interest in the
terminated message, and when that comes.
We just check, was that the last getter
which just terminated?
And in that case, we send the result to
our parent.
If remember, there was an overall timeout
which we
wanted to set.
And once we get this RecieveTimeout here,
we used to tell all children To abort by
sending them a special message.
We can replace that now.
First of all, we use context.children, and
then we just use context.stop
to stop them, which will result in us
getting the terminated message here.
There is one other thing which is new in
this actor,
and that is the use of context.actor of,
with just one argument.
Normally we used a name and it is always a
good idea to give
actors good names so that you can identify
them for example in log messages.
But since names need to be unique within
an actor, it might be cumbersome
to generate them such that this holds.
If you do not specify a name yourself,
akka will choose one.
And it will start with a dollar sign, so
if you ever
see that, that is the result of not giving
a name here.
This part of the name space is reserved
for these internal
names so that they can be guaranteed not
to clash with anything.
Hence, you cannot create an actor whose
name begins with a dollar sign.
The previous example demonstrated the use
of DeathWatch as an end
of conversation marker, but it also has
other uses, for example.
To fail-over.
In this example, we have a major
actor which is supposed to connect to some
database.
It starts out with a prime, where it
creates an actor for some database.
It watches that one and will use that one.
Code is of course, not shown here.
With that has a fatal error and
terminates.
This case is handled and will become the
backup configuration.
And in here,
something else could be done, for example,
connecting to a different database
or storing updates in memory until the
main database comes back online.
You can implement any strategy you want.
So far, we have looked at the consequence
of the actor's end of life cycle.
Now we will investigate what follows from
its ability to restart.
For this,
I will use a small actor hierarchy.
Let's say we have an actor named top here.
It has child actors A and B.
And they again have child actors A1,
A2, and so on.
Child actors and their state are
considered to be part of an actor's state
which is accumulated during its lifetime.
Hence during a restart, children are
affected.
They are either recreated or restarted.
This means If for example, this Actor is
restarted, nothing else happens,
but if this Actor is restarted, this whole
sub-tree is affected,
and if top was to be restarted, then the
whole tree would be affected.
Assuming an equal distribution of failures
in these Actors.
It is already obvious that those at the
bottom
here will experience most restarts of all.
The purpose of a restart was to reset the
actor to a known good state.
This means that all changes the actor did
to its state will be lost during a
restart.
That was the purpose.
But what if these changes are important?
What if they are needed for the function
of the system?
Then they need to be recreated
upon a restart, and that can be a very
inconvenient operation.
Therefore it is desirable to do that as
rarely as possible.
From the observation that the bottom
actors will
be restarted most, it immediately follows
that the more
important the states and its changes are,
the
higher up in the hierarchy they should be
kept.
But there is one thing more which we can
do.
In addition, we can make sure that we
delegate risky tasks
down the hierarchy to have them performed
at the very bottom.
And if something which is risky, goes
wrong.
And causes the actor to restart, the
effect that we'll have will be rather
localized.
Instead of throughout the whole hierarchy.
This is called the error kernel pattern,
and it is one of
the reasons why the application of the
actor mole in Erlang was successful.
Therefore, akka goes one step further.
You have seen that in akka, this
supervision is mandatory.
It is not optional.
So in akka, you are forced to create these
hierarchies.
When we look at the full example of the
[UNKNOWN] checker
from last week, we see that Intuitively,
we apply this pattern.
The receptionist is at the peak of the
hierarchy and
it has the important state which is, which
requests are outstanding.
And the getters, which are exposed to all
the difficulties of parsing input from
websites, for example.
Alright at the bottom, because they're
most likely to fail.
Using the features of supervision and
DeathWatch, we
can make the receptionist and controller
more resilient.
By using the terminated message to react
to unforeseen failure.
Doing that is quite straightforward.
First, we install a SupervisorStrategy.
There is a prefabricated
one, the stoppingStrategy.
For any failure of any child, it will just
issue a stop command.
The second modification which we need to
do
is that we need to register for
DeathWatch.
There was only one place in the
receptionist in runNext where we then need
to call context watch to watch the
controller before we send it the check
message.
The lost modifications are found in the
running behavior.
If we get a successful result back from a
controller.
We now need to stop it, and before we do
that we
call unwatch so that we do not get the
terminated message anymore.
The next thing we then do is, as usual
check whether there is something in the
queue, and run
it if so.
If a controller terminates without having
sent a result,
we will get the terminated message because
we watched it.
In that case, we generate the failed
result for the
client here, and then we go on to the next
job.
In this case, we do not need to check the
actorRef.
For which we get the terminated message
because at
any given point in time, there can be only
one.
This is the reason why we use unwatch
here.
The controller which successfully
completed its mission
is no longer of interest to us.
The terminated if it is received, will
have come from the next one.
Apropos, what happens if we do not
handle terminated messages.
I still owe you an explanation for why it
extends the marker trait possibly harmful.
Let me show you how these 2 are related.
But before we can go there, we need to
look at one more thing first.
What we have learned so far
was that actors can only communicate with
other actors if they know their ActorRef.
Taking a step back and imagining not
abstract
actors but a roomful of people, this
corresponds to pairs
of people talking directly with each other
or groups
forming which send themselves messages in
a circle for example.
But if you have a lot of people in a room,
there is another possibility.
You can shout, and then everybody who
wants
to listen will hear what you are saying.
The same concept exists in akka, and it is
called EventStream.
Publishing messages to an EventStream is
like sending
them, but you just don't know to whom.
You're sending to an unknown audience.
And all actors in the system have the
ability to listen in on certain channels.
The API for that is rather simple.
Publish has the same signature as till,
and in the end it does the same thing.
Once you publish an event, everyone
subscribed
to that type of event will get it.
To subscribe, the subscribe method takes
the ActorRef.
Which wants to receive the notifications
and a
topic in the form of a Java class object.
These classes are similar to Scalas types.
But they're given by what the Java virtual
machine supports, so the
types you can express in this system are
less powerful than Scalas.
Still its very useful.
For example, looking at a
log event trait.
This might have concrete sub classes,
from debug to error for example.
And if you say class of debug, you get the
debug class object.
And if you subscribe to that, you will get
all the debug messages.
If on the other hand you subscribe to the
log event class, you will get all of
these.
An actor can also unsubscribe from a
particular topic.
Or unsubscribe completely from the
EventStream.
This is just a small example which shows
how this looks like in code.
Every actor system has an EventStream.
It is therefore accessible by saying
context.system.eventStream.
And this listener subscribes itself to all
LogEvents
which it will then get and then receive.
And the behavior, and in post stop, it is
good style to unsubscribe from all events.
Armed with this knowledge, we can look at
what happens to unhandled messages.
The actor.receive type is a partial
function, which means
that for any given input, it might not
apply.
Those messages which do not match are
called unhandled and they are passed into
the method with the same name.
The accepts any, and you can override
it but the default behavior is that it is
matching on the type
and if it is a terminated message, then a
new death pact exception is thrown.
The default supervisor strategy will treat
this death pact
exception in a way that it responds with a
stop command.
This is inspired by the Erlang model of
linking 2 processes.
The intention is if I'm monitoring Another
process, and I do not
specially handle the terminated message.
Then what I want is to terminate together
with it.
All other unhandled messages are published
to the
events stream as unhandled messages, and,
as I
have shown you previously, you could for
example,
register a listener to log them if you
want.
In order to demonstrate this feature, I
have modified the main program
of our [UNKNOWN] link checker.
to include the context.watch
for the receptionist.
The reason is that the whole application
exists only to support The
existence of the receptionist, and it has
no purpose once that has died.
And you see simply not handling the
terminated in here will do what is
commented.
We signed the death pact with the
receptionist.
In order to see this in action We
need to make it fail because otherwise
this behavior will not be demonstrated.
So let me hack in a bit here.
This is a crude way to make the actor not
respond.
But it will serve its purpose.
Running the application yields the
well-known failure for the first one.
Then we have 1, 2 successful retrievals.
But on the third one, the controller will
not respond.
It will just stop itself.
Now, we see the application gets Monitored
actor receptionist terminated, and then it
shuts down.
Feel free to experiment with this by
inserting, for example, probabilistic
failures throughout the hierarchy, and see
how supervision takes care of things.

